# Session Snapshot Meta-Skill - Usage Guide

## Overview

The `session-snapshot` meta-skill saves recoverable session state snapshots that capture task context, decisions, and progress. Enables precise resume after crashes, context clears, or multi-day breaks - perfect for long-running development projects and complex multi-session tasks.

**Token Efficiency**: ~400 tokens vs 10K+ tokens for full context restart (96% reduction)

## Quick Start

### Natural Language Invocation
```
"Save a snapshot of our current progress"
"Create a checkpoint before we make these changes"
"I need to take a break, save our session state"
```

### Direct Skill Invocation
```
/session-snapshot
```

## When to Use

‚úÖ **Session Management**:
- Before risky operations (major refactors, schema changes)
- Every 15-20 messages in long sessions
- User says: "save checkpoint", "snapshot state", "save progress"
- Before `/clear` or ending session
- Multi-day projects (save at end of each session)

‚úÖ **Crash Recovery**:
- Session interruptions
- Unexpected disconnections
- System failures
- Context loss scenarios

‚úÖ **Context Switching**:
- Switching between projects
- Taking extended breaks
- Handing off to other developers
- Preserving decision history

## Snapshot Process

### Step 1: Capture Session State
Extract current session information:

**Required fields**:
- `timestamp` - Current date/time
- `task_summary` - 1-line description of overall goal
- `current_phase` - Specific step in progress
- `files_modified` - List with line ranges or "new file"
- `files_read` - Context files examined
- `next_steps` - Ordered todo list (markdown checkboxes)

**Optional fields**:
- `decisions_made` - Key architectural choices
- `context_preservation` - Important background (‚â§200 words)
- `blockers` - Current issues preventing progress
- `test_status` - Pass/fail state
- `commit_sha` - Git commit before changes (if applicable)

### Step 2: Generate Snapshot File
Writes to `.session-snapshot.md` in project root:

```markdown
# Session Snapshot

**Timestamp**: YYYY-MM-DDTHH:MM:SSZ
**Task**: [1-line summary]
**Phase**: [current step]

## Context

[2-4 sentences explaining what we're doing and why]

## Decisions Made

- [Key decision 1 with rationale]
- [Key decision 2 with rationale]

## Files Modified

- `path/to/file.py` (lines 20-150: extracted GraphTopology)
- `path/to/new_file.py` (new file: GraphTopology class)
- `tests/test_file.py` (lines 45-60: updated tests)

## Files Read (Context)

- `path/to/related.py` (understanding BaseAgent interface)
- `CLAUDE.md` (architectural constraints)

## Current State

**Test status**: ‚úÖ All passing | ‚ö†Ô∏è 3 failing | ‚ùå Not run
**Git status**: Clean | Uncommitted changes | Staged changes
**Commit SHA**: abc123def (before modifications)

## Next Steps

- [ ] Update imports in network.py:25
- [ ] Run `pytest tests/test_network.py -v`
- [ ] Fix failing test_topology_creation
- [ ] Commit with message: "refactor: extract GraphTopology from NetworkEnvironment"

## Blockers

- [Issue 1]: [description and potential solution]
- [Issue 2]: [description and potential solution]

## Resume Instructions

### Quick Resume (if context intact)
```
Continue with next step: Update imports in network.py:25
```

### Cold Resume (new session/cleared context)
```
1. Read this file (.session-snapshot.md)
2. Read files in "Files Modified" to see current changes
3. Read files in "Files Read" for context
4. Check test status: pytest tests/test_network.py -v
5. Continue from "Next Steps" checklist
```

### Recovery from Failure
```
If changes broke something:
1. Check git status
2. Compare to commit SHA: git diff abc123def
3. Consider: git reset --hard abc123def (CAUTION: loses changes)
4. Review "Decisions Made" to understand approach
5. Try alternative approach or ask for guidance
```

---
*Generated by session-snapshot skill on YYYY-MM-DD*
```

### Step 3: Add to .gitignore
Ensures snapshot not committed:

```bash
# Check if .gitignore exists and add entry
if ! grep -q ".session-snapshot.md" .gitignore 2>/dev/null; then
  echo "" >> .gitignore
  echo "# Claude Code session snapshots" >> .gitignore
  echo ".session-snapshot.md" >> .gitignore
fi
```

### Step 4: Confirm to User
Shows brief confirmation:

```markdown
‚úÖ **Session snapshot saved**: `.session-snapshot.md`

**Task**: [summary]
**Phase**: [current]
**Next**: [first uncompleted todo]

**Resume command**:
- Same session: "Continue from snapshot"
- New session: "Read .session-snapshot.md and continue"
```

## Resume Workflow

When user returns after break/crash/clear:

### Step 1: Load Snapshot
```bash
# Read the snapshot file
cat .session-snapshot.md
```

### Step 2: Validate State
Check if project state matches snapshot:

```bash
# Compare modified files
git status

# Check test status
pytest tests/ -v --tb=no -q

# Verify snapshot commit (if recorded)
git log --oneline -5
```

### Step 3: Rebuild Context
Read the exact files listed in snapshot:
- Files Modified: See what changed
- Files Read: Rebuild context understanding

### Step 4: Continue Execution
Pick up from "Next Steps" checklist. Mark completed items and proceed.

## Example Usage

### Example 1: Refactoring Session
```
User: We're about to extract GraphTopology from NetworkEnvironment. Save a snapshot first.

Claude: ‚úÖ **Session snapshot saved**: `.session-snapshot.md`

**Task**: Extract GraphTopology component from NetworkEnvironment
**Phase**: Pre-refactoring checkpoint
**Next**: Create src/acp_simulation/environment/graph_topology.py

**Resume**: "Read .session-snapshot.md and continue"
```

### Example 2: Resume After Crash
```
User: My session crashed. Read .session-snapshot.md and continue.

Claude: üìã Resuming from snapshot (2026-01-07 16:30)

**Task**: Extract GraphTopology component
**Progress**: GraphTopology class created, imports partially updated
**Tests**: ‚ö†Ô∏è 3 failing (test_topology_creation, test_get_neighbors, test_graph_properties)

**Next step**: Fix failing tests by updating NetworkEnvironment imports

Continuing...
```

### Example 3: Multi-Day Project
```
Day 1 End:
User: Save checkpoint before I leave for today.

Claude: ‚úÖ Snapshot saved
- Task: Add enterprise topology support (hub-spoke, hierarchical)
- Phase: Completed hub-spoke, starting hierarchical
- Next: Implement hierarchical topology generator

Day 2 Start:
User: Read .session-snapshot.md and continue where we left off.

Claude: üìã Resuming from 2026-01-06 snapshot
- Completed: Hub-spoke topology with gradient vulnerability
- Today: Implementing hierarchical topology (DMZ/internal/endpoints)
- Tests: All passing before hierarchical addition

Starting hierarchical implementation...
```

## Anti-Patterns

‚ùå Don't snapshot every 2-3 messages (too frequent)
‚ùå Don't capture entire file contents (link to lines instead)
‚ùå Don't write verbose context (‚â§200 words)
‚ùå Don't skip "Next Steps" - crucial for resume

‚úÖ Do snapshot before risky changes
‚úÖ Do capture architectural decisions
‚úÖ Do list specific file:line references
‚úÖ Do provide clear resume instructions

## Token Efficiency

- Snapshot creation: ~400 tokens
- Snapshot file size: ~500-800 tokens
- Resume from cold start: ~600 tokens
- Total cost: ~1500 tokens (vs. restarting from scratch: 10k+ tokens)

## Integration with Other Skills

**Before major refactoring**:
```
1. /session-snapshot (save state)
2. /refactoring (do the work)
3. /session-snapshot (save after completion)
```

**During long sessions**:
```
Every ~15 messages: Auto-suggest snapshot if user hasn't saved
```

**With git workflows**:
```
1. /session-snapshot (capture clean state)
2. Make changes
3. /diff-summariser (review changes)
4. Commit
5. /session-snapshot (update to new baseline)
```

## Advanced Features

### Multiple Snapshots
For parallel tasks:
```bash
# Use named snapshots for different workstreams
.session-snapshot-feature-auth.md
.session-snapshot-bugfix-race.md
.session-snapshot-refactor-db.md
```

### Snapshot Comparison
Track progress between snapshots:
```bash
# Compare snapshots to see progress
diff .session-snapshot-monday.md .session-snapshot-friday.md
```

### Team Sharing
Share snapshots with team members:
```bash
# Commit snapshots for team visibility
git add .session-snapshot.md
git commit -m "Add session snapshot for feature X"
```

## Best Practices

### 1. Save Frequently
Establish regular snapshot cadence:
- Before major changes
- After significant milestones
- Every 15-20 messages
- Before ending sessions

### 2. Be Specific
Provide concrete details:
- Exact file paths and line numbers
- Specific test names and commands
- Clear success/failure criteria
- Actionable next steps

### 3. Keep It Concise
Balance detail with brevity:
- Essential information only
- Link to specific locations vs. copying content
- Clear, scannable format
- Easy to read quickly

### 4. Validate State
Ensure accuracy:
- Double-check file paths
- Verify test commands work
- Confirm git status
- Test resume process

## Planned Features

The following configuration options are under consideration for future versions:

**Snapshot Content** (not yet implemented):
- `--minimal`: Essential fields only
- `--comprehensive`: Include all optional fields
- `--technical`: Focus on technical details
- `--business`: Include business context

**Resume Behavior** (not yet implemented):
- `--auto-resume`: Automatically continue after loading
- `--confirm-steps`: Ask before each resume step
- `--dry-run`: Show what would happen without doing it

## Troubleshooting

### Issue 1: Snapshot doesn't match current state
**Solution**: Check git status, compare with snapshot commit SHA

### Issue 2: Can't find snapshot file
**Solution**: Check if in correct directory, verify file exists

### Issue 3: Resume fails due to missing context
**Solution**: Read files mentioned in "Files Read" section

### Issue 4: Tests don't run as expected
**Solution**: Check if test files still exist, verify test environment

## Success Stories

### Multi-Day Project Success
**Scenario**: 3-day refactoring project
**Result**: Perfect continuity across days
**Benefit**: Saved 2 hours of context rebuilding

### Crash Recovery Success
**Scenario**: Session crashed during complex refactoring
**Result**: Resumed exactly where left off
**Benefit**: No lost progress, no confusion

### Team Handoff Success
**Scenario**: Developer handed off to teammate
**Result**: Seamless transition with full context
**Benefit**: Zero ramp-up time for teammate

## Token Efficiency Examples

**Feature Development**:
- Full restart: 12,000 tokens
- Snapshot resume: 800 tokens
- Savings: 93%

**Bug Fix**:
- Full restart: 8,000 tokens
- Snapshot resume: 600 tokens
- Savings: 92%

**Refactoring**:
- Full restart: 15,000 tokens
- Snapshot resume: 900 tokens
- Savings: 94%

## Related Skills

- `meta/skill-extractor` - Extract workflow patterns into new skills
- `git/diff-summariser` - Review changes before snapshot
- `development/refactoring` - Major changes that need checkpoints
- `analysis/code/api-contract-sniffer` - Validate API changes

---

**Ready to never lose context again?** Just tell Claude: "Save a snapshot" or "Create a checkpoint"!