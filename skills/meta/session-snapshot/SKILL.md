---
name: session-snapshot
description: Save session state snapshots with precise resume instructions for crash recovery or context clearing. Use when user says "save snapshot", "checkpoint progress", or before long/risky operations.
---

# Session Snapshot Skill

## üéØ Purpose
Create recoverable session snapshots that capture task context, decisions, and progress. Enables precise resume after crashes, context clears, or multi-day breaks.

## üöÄ Key Features

- **Session recovery**: Capture task context, decisions, and progress for precise resume after crashes or breaks
- **Token efficiency**: ~1500 tokens total vs 10k+ for restart (85% reduction)
- **Multi-level resume**: Quick resume (context intact), cold resume (new session), recovery from failure
- **Git integration**: Automatic .gitignore handling, commit SHA tracking
- **Multiple snapshots**: Named snapshots for parallel tasks (`.session-snapshot-[name].md`)
- **Clear resume workflow**: Step-by-step instructions for rebuilding context

## üìã Usage

**When to use**:
- Before risky operations (major refactors, schema changes)
- Every 15-20 messages in long sessions
- User says: "save checkpoint", "snapshot state", "save progress"
- Before `/clear` or ending session
- Multi-day projects (save at end of each session)

### Instructions

### Step 1: Capture Session State

Extract current session information:

**Required fields**:
- `timestamp` - Current date/time
- `task_summary` - 1-line description of overall goal
- `current_phase` - Specific step in progress
- `files_modified` - List with line ranges or "new file"
- `files_read` - Context files examined
- `next_steps` - Ordered todo list (markdown checkboxes)

**Optional fields**:
- `decisions_made` - Key architectural choices
- `context_preservation` - Important background (‚â§200 words)
- `blockers` - Current issues preventing progress
- `test_status` - Pass/fail state
- `commit_sha` - Git commit before changes (if applicable)

### Step 2: Generate Snapshot File

Write to `.session-snapshot.md` in project root:

```markdown
# Session Snapshot

**Timestamp**: YYYY-MM-DDTHH:MM:SSZ
**Task**: [1-line summary]
**Phase**: [current step]

## Context

[2-4 sentences explaining what we're doing and why]

## Decisions Made

- [Key decision 1 with rationale]
- [Key decision 2 with rationale]

## Files Modified

- `path/to/file.py` (lines 20-150: extracted GraphTopology)
- `path/to/new_file.py` (new file: GraphTopology class)
- `tests/test_file.py` (lines 45-60: updated tests)

## Files Read (Context)

- `path/to/related.py` (understanding BaseAgent interface)
- `CLAUDE.md` (architectural constraints)

## Current State

**Test status**: ‚úÖ All passing | ‚ö†Ô∏è 3 failing | ‚ùå Not run
**Git status**: Clean | Uncommitted changes | Staged changes
**Commit SHA**: abc123def (before modifications)

## Next Steps

- [ ] Update imports in network.py:25
- [ ] Run `pytest tests/test_network.py -v`
- [ ] Fix failing test_topology_creation
- [ ] Commit with message: "refactor: extract GraphTopology from NetworkEnvironment"

## Blockers

- [Issue 1]: [description and potential solution]
- [Issue 2]: [description and potential solution]

## Resume Instructions

### Quick Resume (if context intact)
```
Continue with next step: Update imports in network.py:25
```

### Cold Resume (new session/cleared context)
```
1. Read this file (.session-snapshot.md)
2. Read files in "Files Modified" to see current changes
3. Read files in "Files Read" for context
4. Check test status: pytest tests/test_network.py -v
5. Continue from "Next Steps" checklist
```

### Recovery from Failure
```
If changes broke something:
1. Check git status
2. Compare to commit SHA: git diff abc123def
3. Consider: git reset --hard abc123def (CAUTION: loses changes)
4. Review "Decisions Made" to understand approach
5. Try alternative approach or ask for guidance
```

---
*Generated by session-snapshot skill on YYYY-MM-DD*
```

### Step 3: Add to .gitignore

Ensure snapshot not committed:

```bash
# Check if .gitignore exists and add entry
if ! grep -q ".session-snapshot.md" .gitignore 2>/dev/null; then
  echo "" >> .gitignore
  echo "# Claude Code session snapshots" >> .gitignore
  echo ".session-snapshot.md" >> .gitignore
fi
```

### Step 4: Confirm to User

Show brief confirmation:

```markdown
‚úÖ **Session snapshot saved**: `.session-snapshot.md`

**Task**: [summary]
**Phase**: [current]
**Next**: [first uncompleted todo]

**Resume command**:
- Same session: "Continue from snapshot"
- New session: "Read .session-snapshot.md and continue"
```

## Resume Workflow

When user returns after break/crash/clear:

### Step 1: Load Snapshot

```bash
# Read the snapshot file
cat .session-snapshot.md
```

### Step 2: Validate State

Check if project state matches snapshot:

```bash
# Compare modified files
git status

# Check test status
pytest tests/ -v --tb=no -q

# Verify snapshot commit (if recorded)
git log --oneline -5
```

### Step 3: Rebuild Context

Read the exact files listed in snapshot:
- Files Modified: See what changed
- Files Read: Rebuild context understanding

### Step 4: Continue Execution

Pick up from "Next Steps" checklist. Mark completed items and proceed.

## üéõÔ∏è Parameters

**None required** - The skill auto-captures session state from current context.

**Optional naming** (for multiple snapshots):
- Default: `.session-snapshot.md`
- Named: `.session-snapshot-[name].md` (e.g., `.session-snapshot-feature-auth.md`)

**Captured fields**:
- **Required**: timestamp, task_summary, current_phase, files_modified, files_read, next_steps
- **Optional**: decisions_made, context_preservation, blockers, test_status, commit_sha

## Anti-Patterns

‚ùå Don't snapshot every 2-3 messages (too frequent)
‚ùå Don't capture entire file contents (link to lines instead)
‚ùå Don't write verbose context (‚â§200 words)
‚ùå Don't skip "Next Steps" - crucial for resume

‚úÖ Do snapshot before risky changes
‚úÖ Do capture architectural decisions
‚úÖ Do list specific file:line references
‚úÖ Do provide clear resume instructions

## Token Efficiency

- Snapshot creation: ~400 tokens
- Snapshot file size: ~500-800 tokens
- Resume from cold start: ~600 tokens
- Total cost: ~1500 tokens (vs. restarting from scratch: 10k+ tokens)

## üí° Examples

### Example 1: Refactoring Session

**Trigger**:
```
User: We're about to extract GraphTopology from NetworkEnvironment. Save a snapshot first.
```

**Execution**:
1. Capture current state (clean git, tests passing)
2. Record decision: "Use composition over inheritance"
3. List files to modify: network.py, new graph_topology.py
4. Create .session-snapshot.md with all context
5. Add to .gitignore

**Output**:
```
‚úÖ Session snapshot saved: .session-snapshot.md

Task: Extract GraphTopology component from NetworkEnvironment
Phase: Pre-refactoring checkpoint
Next: Create src/acp_simulation/environment/graph_topology.py

Resume: "Read .session-snapshot.md and continue"
```

### Example 2: Resume After Crash

**Trigger**:
```
User: My session crashed. Read .session-snapshot.md and continue.
```

**Execution**:
1. Read .session-snapshot.md
2. Check git status (sees modified network.py)
3. Read network.py:20-150 to see partial extraction
4. Run tests ‚Üí 3 failing
5. Review "Decisions Made" and "Blockers"
6. Continue from "Next Steps" checklist

**Output**:
```
üìã Resuming from snapshot (2026-01-07 16:30)

Task: Extract GraphTopology component
Progress: GraphTopology class created, imports partially updated
Tests: ‚ö†Ô∏è 3 failing (test_topology_creation, test_get_neighbors, test_graph_properties)

Next step: Fix failing tests by updating NetworkEnvironment imports

Continuing...
```

### Example 3: Multi-Day Project

**Day 1 End**:
```
User: Save checkpoint before I leave for today.

Claude: ‚úÖ Snapshot saved
- Task: Add enterprise topology support (hub-spoke, hierarchical)
- Phase: Completed hub-spoke, starting hierarchical
- Next: Implement hierarchical topology generator
```

**Day 2 Start**:
```
User: Read .session-snapshot.md and continue where we left off.

Claude: üìã Resuming from 2026-01-06 snapshot
- Completed: Hub-spoke topology with gradient vulnerability
- Today: Implementing hierarchical topology (DMZ/internal/endpoints)
- Tests: All passing before hierarchical addition

Starting hierarchical implementation...
```

### Example 4: Parallel Task Snapshots

**Trigger**:
```
User: I'm working on authentication and a bug fix in parallel. Save separate snapshots.
```

**Execution**:
Create named snapshots:
- `.session-snapshot-feature-auth.md` - Auth feature work
- `.session-snapshot-bugfix-race.md` - Race condition fix

**Output**:
```
‚úÖ **Snapshots saved**:
- `.session-snapshot-feature-auth.md` (OAuth2 implementation)
- `.session-snapshot-bugfix-race.md` (Race condition in cache)

**Resume**: "Read [snapshot-name] and continue"
```

## üéÅ Output

### Snapshot File Structure

Creates `.session-snapshot.md` in project root:

```markdown
# Session Snapshot

**Timestamp**: 2026-01-15T14:30:00Z
**Task**: Extract GraphTopology component from NetworkEnvironment
**Phase**: Pre-refactoring checkpoint

## Context
We're extracting the graph topology logic from NetworkEnvironment into a separate GraphTopology class to improve modularity and testability.

## Decisions Made
- Use composition over inheritance for topology management
- Keep existing API surface for backward compatibility

## Files Modified
- `src/network.py` (lines 20-150: extracted GraphTopology)
- `src/graph_topology.py` (new file: GraphTopology class)
- `tests/test_network.py` (lines 45-60: updated tests)

## Next Steps
- [ ] Update imports in network.py:25
- [ ] Run `pytest tests/test_network.py -v`
- [ ] Commit with message: "refactor: extract GraphTopology"

## Resume Instructions
### Quick Resume: Continue with next step: Update imports
### Cold Resume: Read this file, check git status, run tests, continue from checklist
```

### Confirmation Message

Shows brief confirmation:

```
‚úÖ **Session snapshot saved**: `.session-snapshot.md`

**Task**: Extract GraphTopology component
**Phase**: Pre-refactoring checkpoint
**Next**: Update imports in network.py:25

**Resume**: "Read .session-snapshot.md and continue"
```

## Integration with Other Skills

**Before major refactoring**:
```
1. /session-snapshot (save state)
2. /refactoring (do the work)
3. /session-snapshot (save after completion)
```

**During long sessions**:
```
Every ~15 messages: Auto-suggest snapshot if user hasn't saved
```

**With git workflows**:
```
1. /session-snapshot (capture clean state)
2. Make changes
3. /diff-summariser (review changes)
4. Commit
5. /session-snapshot (update to new baseline)
```

## ‚ö†Ô∏è Important Notes

- Snapshots are **local only** (.gitignore'd)
- Multiple snapshots: Use `.session-snapshot-[name].md` for parallel tasks
- For team sharing: Remove .gitignore and commit snapshots deliberately
- Claude can auto-detect when to suggest snapshots (long sessions, risky ops)
- **Cross-platform**: Bash commands require bash environment (Git Bash on Windows, native on macOS/Linux)
- **Windows users**: Use Git Bash or WSL for .gitignore automation; can create snapshots manually if needed

## Related Skills

- `meta/skill-extractor` - Extract workflow patterns into new skills
- `git/diff-summariser` - Review changes before snapshot
- `development/refactoring` - Major changes that need checkpoints
- `git/repo-briefing` - Initial project context (complement to snapshots)
