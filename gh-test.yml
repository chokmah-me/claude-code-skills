name: Changelog Automation

on:
  push:
    branches:
      - main
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Version for release (e.g., 3.1.0)'
        required: false
        type: string
      release_type:
        description: 'Type of release'
        required: false
        type: choice
        options:
          - 'patch'
          - 'minor'
          - 'major'
        default: 'minor'

env:
  PYTHON_VERSION: '3.11'

jobs:
  update-changelog:
    name: Update Changelog
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Analyze changes and update changelog
        run: |
          echo "[LOG] Analyzing changes for changelog..."
          python -c "
import os
import re
import json
from pathlib import Path
from datetime import datetime
import subprocess

class ChangelogGenerator:
    def __init__(self):
        self.changes = {
            'added': [],
            'changed': [],
            'deprecated': [],
            'removed': [],
            'fixed': [],
            'security': []
        }
        self.version_info = {
            'current_version': '3.0.0',
            'next_version': None,
            'release_date': datetime.now().strftime('%Y-%m-%d')
        }
    
    def get_current_version(self):
        '''Get current version from various sources'''
        # Try to get from git tags
        try:
            result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                version = result.stdout.strip()
                # Remove 'v' prefix if present
                if version.startswith('v'):
                    version = version[1:]
                self.version_info['current_version'] = version
                return version
        except:
            pass
        
        # Try to get from README
        readme_path = Path('README.md')
        if readme_path.exists():
            try:
                with open(readme_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                # Look for version patterns
                version_match = re.search(r'v?(\d+\.\d+\.\d+)', content)
                if version_match:
                    self.version_info['current_version'] = version_match.group(1)
                    return version_match.group(1)
            except:
                pass
        
        return self.version_info['current_version']
    
    def calculate_next_version(self, release_type='minor'):
        '''Calculate next version based on release type'''
        current = self.get_current_version()
        major, minor, patch = map(int, current.split('.'))
        
        if release_type == 'major':
            major += 1
            minor = 0
            patch = 0
        elif release_type == 'minor':
            minor += 1
            patch = 0
        else:  # patch
            patch += 1
        
        next_version = f'{major}.{minor}.{patch}'
        self.version_info['next_version'] = next_version
        return next_version
    
    def analyze_recent_commits(self, num_commits=10):
        '''Analyze recent commits for changelog entries'''
        try:
            result = subprocess.run(['git', 'log', f'-{num_commits}', '--pretty=format:%H|%s|%b'], 
                                  capture_output=True, text=True)
            if result.returncode != 0:
                return
            
            commits = result.stdout.strip().split('\n')
            
            for commit in commits:
                if '|' not in commit:
                    continue
                    
                hash_part, subject, body = commit.split('|', 2)
                
                # Categorize based on conventional commit format
                if subject.startswith('feat') or subject.startswith('add'):
                    self.changes['added'].append(self.format_commit_entry(subject, body))
                elif subject.startswith('fix') or subject.startswith('bug'):
                    self.changes['fixed'].append(self.format_commit_entry(subject, body))
                elif subject.startswith('change') or subject.startswith('update'):
                    self.changes['changed'].append(self.format_commit_entry(subject, body))
                elif subject.startswith('remove') or subject.startswith('delete'):
                    self.changes['removed'].append(self.format_commit_entry(subject, body))
                elif subject.startswith('security'):
                    self.changes['security'].append(self.format_commit_entry(subject, body))
                elif subject.startswith('deprecat'):
                    self.changes['deprecated'].append(self.format_commit_entry(subject, body))
                
        except Exception as e:
            print(f'[WARN]  Error analyzing commits: {e}')
    
    def format_commit_entry(self, subject, body):
        '''Format a commit entry for changelog'''
        # Remove conventional commit prefix
        subject = re.sub(r'^(feat|fix|add|change|update|remove|delete|security| deprecat)\s*[:!]?\s*', '', subject, flags=re.IGNORECASE)
        
        entry = subject.strip()
        if body.strip():
            # Add first line of body as additional detail
            body_lines = body.strip().split('\n')
            if body_lines[0].strip():
                entry += f' ({body_lines[0].strip()})'
        
        return entry
    
    def analyze_skill_changes(self):
        '''Analyze changes to skills directory'''
        skills_changes = {
            'new_skills': [],
            'updated_skills': [],
            'removed_skills': []
        }
        
        # Check for skills in different locations
        skill_locations = ['skills', '.claude/skills']
        
        for location in skill_locations:
            skills_path = Path(location)
            if not skills_path.exists():
                continue
            
            for category_dir in skills_path.iterdir():
                if category_dir.is_dir() and not category_dir.name.startswith('.'):
                    category = category_dir.name
                    
                    for skill_dir in category_dir.iterdir():
                        if skill_dir.is_dir() and not skill_dir.name.startswith('.'):
                            skill_name = skill_dir.name
                            
                            # Check if this is a new or updated skill
                            skill_file = skill_dir / 'SKILL.md'
                            if skill_file.exists():
                                try:
                                    # Get modification time
                                    mtime = skill_file.stat().st_mtime
                                    days_ago = (datetime.now().timestamp() - mtime) / 86400
                                    
                                    if days_ago < 7:  # Recently modified
                                        skills_changes['updated_skills'].append({
                                            'name': skill_name,
                                            'category': category,
                                            'location': location
                                        })
                                    
                                    # Check if it's very new (created in last 7 days)
                                    ctime = skill_file.stat().st_ctime
                                    days_since_creation = (datetime.now().timestamp() - ctime) / 86400
                                    
                                    if days_since_creation < 7:
                                        skills_changes['new_skills'].append({
                                            'name': skill_name,
                                            'category': category,
                                            'location': location
                                        })
                                        
                                except Exception as e:
                                    print(f'[WARN]  Error checking skill {skill_name}: {e}')
        
        return skills_changes
    
    def generate_changelog_entry(self, version=None, release_type='minor'):
        '''Generate a new changelog entry'''
        if not version:
            version = self.calculate_next_version(release_type)
        
        lines = []
        lines.append(f'## [{version}] - {self.version_info[\"release_date\"]}')
        lines.append('')
        
        # Analyze recent changes
        self.analyze_recent_commits()
        skill_changes = self.analyze_skill_changes()
        
        # Add skill changes
        if skill_changes['new_skills']:
            lines.append('### Added')
            for skill in skill_changes['new_skills']:
                lines.append(f'- New skill: {skill[\"name\"].replace(\"-\", \" \").title()} ({skill[\"category\"]})')
            lines.append('')
        
        if skill_changes['updated_skills']:
            lines.append('### Changed')
            for skill in skill_changes['updated_skills']:
                lines.append(f'- Updated skill: {skill[\"name\"].replace(\"-\", \" \").title()} ({skill[\"category\"]})')
            lines.append('')
        
        # Add commit-based changes
        for category, entries in self.changes.items():
            if entries:
                category_title = category.title()
                lines.append(f'### {category_title}')
                for entry in entries[:5]:  # Limit to 5 entries per category
                    lines.append(f'- {entry}')
                if len(entries) > 5:
                    lines.append(f'- ... and {len(entries) - 5} more {category} entries')
                lines.append('')
        
        # If no changes detected, add a default message
        if not any(self.changes.values()) and not skill_changes['new_skills'] and not skill_changes['updated_skills']:
            lines.append('### Changed')
            lines.append('- Minor improvements and bug fixes')
            lines.append('')
        
        return '\n'.join(lines)
    
    def update_changelog_file(self, new_entry, version=None):
        '''Update the CHANGELOG.md file'''
        changelog_path = Path('CHANGELOG.md')
        
        # Create changelog if it doesn't exist
        if not changelog_path.exists():
            with open(changelog_path, 'w', encoding='utf-8') as f:
                f.write('# Changelog\n\n')
                f.write('All notable changes to this project will be documented in this file.\n\n')
        
        try:
            with open(changelog_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Find the position to insert the new entry (after header)
            header_end = content.find('\n', content.find('# Changelog')) + 1
            if header_end == -1:
                header_end = len(content)
            
            # Insert the new entry
            new_content = content[:header_end] + '\n' + new_entry + '\n' + content[header_end:]
            
            with open(changelog_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            print(f'[OK] Changelog updated with version {version or \"new entry\"}')
            return True
            
        except Exception as e:
            print(f'[ERROR] Error updating changelog: {e}')
            return False

def main():
    generator = ChangelogGenerator()
    
    # Get version from input or calculate
    version = os.environ.get('VERSION')
    release_type = os.environ.get('RELEASE_TYPE', 'minor')
    
    if not version:
        version = generator.calculate_next_version(release_type)
    
    print(f'[LOG] Generating changelog for version {version}...')
    
    # Generate changelog entry
    new_entry = generator.generate_changelog_entry(version, release_type)
    print('Generated changelog entry:')
    print(new_entry)
    print()
    
    # Update changelog file
    if generator.update_changelog_file(new_entry, version):
        # Also create a summary for GitHub Actions
        with open('changelog-summary.txt', 'w') as f:
            f.write(f'Changelog updated for version {version}\\n')
            f.write(f'Release date: {generator.version_info[\"release_date\"]}\\n')
            f.write(f'Changes detected across multiple categories\\n')
        
        return True
    else:
        return False

if __name__ == '__main__':
    import sys
    success = main()
    sys.exit(0 if success else 1)
          "
        env:
          VERSION: ${{ github.event.inputs.version }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet; then
            echo "No changes to changelog"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected in changelog"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push changelog
        if: steps.changes.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          git commit -m "[LOG] Auto-update changelog

          - Added recent changes and updates
          - Generated from commit history
          - Includes skill changes and improvements
          - Auto-generated by GitHub Actions"
          
          git push

      - name: Create release
        if: steps.changes.outputs.changed == 'true' && github.event.inputs.version
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.event.inputs.version }}
          release_name: Release v${{ github.event.inputs.version }}
          body: |
            ## What's New in v${{ github.event.inputs.version }}
            
            See [CHANGELOG.md](CHANGELOG.md) for detailed changes.
            
            ### Auto-generated Release
            This release was automatically generated by the changelog automation workflow.
          draft: false
          prerelease: false

      - name: Upload changelog artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: changelog-artifacts
          path: |
            CHANGELOG.md
            changelog-summary.txt
          retention-days: 90

      - name: Comment on PR
        if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let comment = `## [LOG] Changelog Update
            
            [OK] Changelog has been automatically updated with this merged PR!
            
            The changelog now includes:
            - This PR's changes and improvements
            - Recent skill additions or updates
            - Bug fixes and enhancements
            
            **Next Steps:**
            - Review the updated [CHANGELOG.md](../blob/main/CHANGELOG.md)
            - Consider creating a release if this represents a significant update
            
            ---
            *This comment was automatically generated by the changelog automation workflow.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });