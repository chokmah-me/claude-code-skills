name: Skill Template Validator

on:
  pull_request:
    paths:
      - 'skills/**'
      - '.claude/skills/**'
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'

jobs:
  validate-skill-templates:
    name: Validate Skill Templates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml markdown

      - name: Validate skill structure
        run: |
          echo "ðŸ” Validating skill template structure..."
          python -c "
import os
import re
from pathlib import Path
import yaml

class SkillTemplateValidator:
    def __init__(self):
        self.errors = []
        self.warnings = []
        self.stats = {'total_skills': 0, 'valid_skills': 0}
        
    def validate_skill_template(self, skill_path, category, skill_name):
        '''Validate a skill follows the template structure'''
        self.stats['total_skills'] += 1
        skill_dir = Path(skill_path)
        
        print(f'ðŸ” Validating {category}/{skill_name}...')
        
        # Check required files
        skill_file = skill_dir / 'SKILL.md'
        readme_file = skill_dir / 'README.md'
        
        if not skill_file.exists():
            self.errors.append(f'{category}/{skill_name}: Missing required SKILL.md')
            return False
            
        # Validate SKILL.md structure
        try:
            with open(skill_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for required sections
            required_sections = ['Purpose:', 'Usage:', 'Examples:']
            for section in required_sections:
                if section not in content:
                    self.warnings.append(f'{category}/{skill_name}: Missing {section} section')
            
            # Check for skill invocation pattern
            if f'/{skill_name}' not in content and skill_name != 'refactoring':
                self.warnings.append(f'{category}/{skill_name}: Should show skill invocation like /{skill_name}')
            
            # Check for token efficiency mention (important for Claude skills)
            if 'token' not in content.lower() and 'efficiency' not in content.lower():
                self.warnings.append(f'{category}/{skill_name}: Consider mentioning token efficiency')
            
            # Validate YAML frontmatter if present
            if content.startswith('---'):
                try:
                    parts = content.split('---')
                    if len(parts) >= 3:
                        yaml_content = parts[1]
                        metadata = yaml.safe_load(yaml_content)
                        if isinstance(metadata, dict):
                            # Check for recommended metadata
                            if 'version' not in metadata:
                                self.warnings.append(f'{category}/{skill_name}: Consider adding version in YAML frontmatter')
                            if 'category' not in metadata:
                                self.warnings.append(f'{category}/{skill_name}: Consider adding category in YAML frontmatter')
                except yaml.YAMLError as e:
                    self.errors.append(f'{category}/{skill_name}: Invalid YAML frontmatter: {e}')
            
            # Check content length
            if len(content) < 200:
                self.warnings.append(f'{category}/{skill_name}: SKILL.md seems very short (under 200 chars)')
            elif len(content) > 5000:
                self.warnings.append(f'{category}/{skill_name}: SKILL.md is very long (over 5000 chars), consider splitting')
            
            self.stats['valid_skills'] += 1
            return True
            
        except Exception as e:
            self.errors.append(f'{category}/{skill_name}: Error reading SKILL.md: {e}')
            return False
    
    def validate_readme(self, skill_path, category, skill_name):
        '''Validate README.md if it exists'''
        readme_file = Path(skill_path) / 'README.md'
        
        if not readme_file.exists():
            self.warnings.append(f'{category}/{skill_name}: Missing README.md (recommended)')
            return
        
        try:
            with open(readme_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for basic structure
            if '# ' not in content:
                self.warnings.append(f'{category}/{skill_name}: README.md should have a main heading')
            
            # Check for code examples
            if '```' not in content:
                self.warnings.append(f'{category}/{skill_name}: README.md should include code examples')
            
            # Check for sections
            recommended_sections = ['overview', 'usage', 'examples', 'installation']
            found_sections = sum(1 for section in recommended_sections if section in content.lower())
            
            if found_sections < 2:
                self.warnings.append(f'{category}/{skill_name}: README.md could benefit from more sections')
                
        except Exception as e:
            self.errors.append(f'{category}/{skill_name}: Error reading README.md: {e}')
    
    def generate_report(self):
        '''Generate validation report'''
        print('\n' + '='*60)
        print('ðŸ“‹ SKILL TEMPLATE VALIDATION REPORT')
        print('='*60)
        
        print(f'\nðŸ“Š Statistics:')
        print(f'  Total Skills Checked: {self.stats[\"total_skills\"]}')
        print(f'  Valid Skills: {self.stats[\"valid_skills\"]}')
        print(f'  Success Rate: {(self.stats[\"valid_skills\"]/max(self.stats[\"total_skills\"], 1)*100):.1f}%')
        
        if self.errors:
            print(f'\nâŒ Errors ({len(self.errors)}):')
            for error in self.errors:
                print(f'  - {error}')
        
        if self.warnings:
            print(f'\nâš ï¸  Warnings ({len(self.warnings)}):')
            for warning in self.warnings:
                print(f'  - {warning}')
        
        print('\n' + '='*60)
        
        # Return appropriate exit code
        if self.errors:
            print('âŒ Skill template validation FAILED')
            return False
        else:
            print('âœ… Skill template validation PASSED')
            return True

def main():
    validator = SkillTemplateValidator()
    
    # Check multiple possible skill locations
    skill_locations = [
        ('skills', 'skills'),
        ('.claude/skills', '.claude/skills')
    ]
    
    for base_path, display_name in skill_locations:
        skills_dir = Path(base_path)
        if skills_dir.exists():
            print(f'ðŸ“ Scanning {display_name} directory...')
            
            for category_dir in skills_dir.iterdir():
                if category_dir.is_dir() and not category_dir.name.startswith('.'):
                    category = category_dir.name
                    print(f'  ðŸ“‚ Category: {category}')
                    
                    for skill_dir in category_dir.iterdir():
                        if skill_dir.is_dir() and not skill_dir.name.startswith('.'):
                            skill_name = skill_dir.name
                            if validator.validate_skill_template(skill_dir, category, skill_name):
                                validator.validate_readme(skill_dir, category, skill_name)
    
    # Generate report and return status
    return validator.generate_report()

if __name__ == '__main__':
    import sys
    success = main()
    sys.exit(0 if success else 1)
          "

      - name: Generate validation report
        if: always()
        run: |
          echo "ðŸ“‹ Generating validation summary..."
          echo "## Skill Template Validation Summary" > validation-report.md
          echo "" >> validation-report.md
          echo "âœ… Validation completed!" >> validation-report.md
          echo "" >> validation-report.md
          echo "**Check the workflow logs above for detailed results.**" >> validation-report.md

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let comment = `## ðŸ” Skill Template Validation
            
            âœ… Skill template validation completed!
            
            This workflow checks that skills follow the established template structure:
            - âœ¨ Required files (SKILL.md, README.md)
            - ðŸ“‹ Proper section structure (Purpose, Usage, Examples)
            - ðŸŽ¯ Skill invocation patterns
            - âš¡ Token efficiency mentions
            - ðŸ“– Documentation quality
            
            **Status**: ${{
              '${{ job.status }}' === 'success' ? 'âœ… PASSED' : 'âŒ FAILED'
            }}
            
            Check the [workflow logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed results.
            
            ---
            *This comment was automatically generated by the skill template validator.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Generate summary
        if: always()
        run: |
          echo "## ðŸ” Skill Template Validation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Skill template validation workflow completed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This workflow validates that skills follow the established template structure." >> $GITHUB_STEP_SUMMARY