name: Skill Consistency Checker

on:
  pull_request:
    paths:
      - 'skills/**'
      - '.claude/skills/**'
  push:
    branches:
      - main
      - develop
  schedule:
    # Run weekly consistency checks
    - cron: '0 9 * * 1'
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'

jobs:
  check-consistency:
    name: Check Skill Consistency
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Check skill consistency
        run: |
          echo "ğŸ” Checking skill consistency across the repository..."
          python -c "
import os
import re
from pathlib import Path
from collections import defaultdict
import json

class SkillConsistencyChecker:
    def __init__(self):
        self.issues = []
        self.warnings = []
        self.stats = {}
        self.skill_patterns = {
            'naming': [],
            'categories': defaultdict(list),
            'structures': defaultdict(list),
            'dependencies': defaultdict(set)
        }
    
    def scan_all_skills(self):
        '''Scan all skills in the repository'''
        skill_locations = [
            ('skills', 'skills'),
            ('.claude/skills', '.claude/skills')
        ]
        
        for base_path, location_name in skill_locations:
            skills_dir = Path(base_path)
            if skills_dir.exists():
                print(f'ğŸ“ Scanning {location_name} directory...')
                
                for category_dir in skills_dir.iterdir():
                    if category_dir.is_dir() and not category_dir.name.startswith('.'):
                        category = category_dir.name
                        
                        for skill_dir in category_dir.iterdir():
                            if skill_dir.is_dir() and not skill_dir.name.startswith('.'):
                                skill_name = skill_dir.name
                                
                                skill_info = self.analyze_skill_structure(skill_dir, category, skill_name, location_name)
                                self.skill_patterns['categories'][category].append(skill_info)
                                self.skill_patterns['naming'].append(skill_name)
    
    def analyze_skill_structure(self, skill_path, category, skill_name, location):
        '''Analyze the structure of a single skill'''
        skill_file = skill_path / 'SKILL.md'
        readme_file = skill_path / 'README.md'
        template_file = skill_path / 'template.md'
        
        info = {
            'name': skill_name,
            'category': category,
            'location': location,
            'has_skill_md': skill_file.exists(),
            'has_readme': readme_file.exists(),
            'has_template': template_file.exists(),
            'structure_score': 0,
            'issues': []
        }
        
        # Analyze SKILL.md
        if skill_file.exists():
            try:
                with open(skill_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Check for required elements
                required_elements = {
                    'purpose': bool(re.search(r'Purpose:', content, re.IGNORECASE)),
                    'usage': bool(re.search(r'Usage:', content, re.IGNORECASE)),
                    'examples': bool(re.search(r'Examples?:', content, re.IGNORECASE)),
                    'skill_invocation': f'/{skill_name}' in content or skill_name == 'refactoring',
                    'token_mention': 'token' in content.lower() or 'efficiency' in content.lower()
                }
                
                # Calculate structure score
                info['structure_score'] = sum(required_elements.values()) / len(required_elements)
                
                # Record missing elements as issues
                for element, present in required_elements.items():
                    if not present:
                        info['issues'].append(f'Missing {element}')
                
                # Check for YAML frontmatter
                if content.startswith('---'):
                    try:
                        parts = content.split('---')
                        if len(parts) >= 3:
                            # Valid YAML frontmatter
                            info['has_yaml_frontmatter'] = True
                        else:
                            info['issues'].append('Invalid YAML frontmatter structure')
                    except:
                        info['issues'].append('YAML frontmatter parsing error')
                else:
                    info['has_yaml_frontmatter'] = False
                
                # Check content length and quality
                word_count = len(content.split())
                if word_count < 100:
                    info['issues'].append('Content too short (under 100 words)')
                elif word_count > 3000:
                    info['issues'].append('Content very long (over 3000 words)')
                
                # Extract dependencies
                self.extract_dependencies(content, skill_name)
                
            except Exception as e:
                info['issues'].append(f'Error reading SKILL.md: {e}')
        else:
            info['issues'].append('Missing SKILL.md')
        
        # Analyze README.md
        if readme_file.exists():
            try:
                with open(readme_file, 'r', encoding='utf-8') as f:
                    readme_content = f.read()
                
                # Check README structure
                readme_elements = {
                    'has_heading': bool(re.search(r'^#+ ', readme_content, re.MULTILINE)),
                    'has_code_examples': '```' in readme_content,
                    'has_sections': len(re.findall(r'^#+ ', readme_content, re.MULTILINE)) >= 2,
                    'reasonable_length': 50 < len(readme_content.split()) < 2000
                }
                
                for element, present in readme_elements.items():
                    if not present:
                        info['issues'].append(f'README issue: {element}')
                        
            except Exception as e:
                info['issues'].append(f'Error reading README.md: {e}')
        
        # Record structure type
        structure_key = f\"skill_md:{info['has_skill_md']},readme:{info['has_readme']},template:{info['has_template']}\"
        self.skill_patterns['structures'][structure_key].append(skill_name)
        
        return info
    
    def extract_dependencies(self, content, skill_name):
        '''Extract skill dependencies from content'''
        # Look for skill invocation patterns
        skill_pattern = r'/([a-zA-Z0-9-]+)'
        matches = re.findall(skill_pattern, content)
        
        for match in matches:
            if match != skill_name:  # Don't count self-references
                self.skill_patterns['dependencies'][skill_name].add(match)
    
    def check_naming_consistency(self):
        '''Check for consistent naming patterns'''
        naming_issues = []
        
        # Check for inconsistent naming patterns
        kebab_case = [name for name in self.skill_patterns['naming'] if '-' in name]
        snake_case = [name for name in self.skill_patterns['naming'] if '_' in name]
        camel_case = [name for name in self.skill_patterns['naming'] if re.search(r'[a-z][A-Z]', name)]
        
        if len(self.skill_patterns['naming']) > 0:
            if len(kebab_case) > 0 and len(snake_case) > 0:
                naming_issues.append('Mixed naming conventions detected: both kebab-case and snake_case skills found')
            
            if len(camel_case) > 0 and (len(kebab_case) > 0 or len(snake_case) > 0):
                naming_issues.append('Mixed naming conventions detected: both camelCase and other conventions found')
            
            # Check for overly long names
            long_names = [name for name in self.skill_patterns['naming'] if len(name) > 30]
            if long_names:
                naming_issues.append(f'Skills with overly long names: {\", \".join(long_names[:3])}{\"...\" if len(long_names) > 3 else \"\"}')
            
            # Check for very short names
            short_names = [name for name in self.skill_patterns['naming'] if len(name) < 3]
            if short_names:
                naming_issues.append(f'Skills with very short names: {\", \".join(short_names)}')
        
        return naming_issues
    
    def check_structure_consistency(self):
        '''Check for consistent skill structures'''
        structure_issues = []
        
        if len(self.skill_patterns['structures']) > 1:
            # Multiple structure patterns found
            structure_issues.append('Inconsistent skill structures detected:')
            for structure, skills in self.skill_patterns['structures'].items():
                structure_issues.append(f'  - {structure}: {len(skills)} skills ({\", \".join(skills[:3])}{\"...\" if len(skills) > 3 else \"\"})')
        
        # Check for skills missing recommended files
        for category, skills in self.skill_patterns['categories'].items():
            missing_readme = [s['name'] for s in skills if not s['has_readme']]
            missing_template = [s['name'] for s in skills if category == 'meta' and not s['has_template']]
            
            if missing_readme:
                structure_issues.append(f'{category}: Skills missing README.md: {\", \".join(missing_readme[:5])}{\"...\" if len(missing_readme) > 5 else \"\"}')
            
            if missing_template:
                structure_issues.append(f'{category}: Meta skills missing template.md: {\", \".join(missing_template)}')
        
        return structure_issues
    
    def check_quality_scores(self):
        '''Check skill quality scores'''
        quality_issues = []
        
        low_quality_skills = []
        for category, skills in self.skill_patterns['categories'].items():
            for skill in skills:
                if skill['structure_score'] < 0.6:  # Less than 60% of required elements
                    low_quality_skills.append({
                        'name': skill['name'],
                        'category': category,
                        'score': skill['structure_score'],
                        'issues': skill['issues']
                    })
        
        if low_quality_skills:
            quality_issues.append(f'Skills with low structure quality (< 60%):')
            for skill in sorted(low_quality_skills, key=lambda x: x['score'])[:5]:
                quality_issues.append(f'  - {skill[\"category\"]}/{skill[\"name\"]}: {skill[\"score\"]:.1%} ({len(skill[\"issues\"])} issues)')
            if len(low_quality_skills) > 5:
                quality_issues.append(f'  ... and {len(low_quality_skills) - 5} more')
        
        return quality_issues
    
    def check_circular_dependencies(self):
        '''Check for circular dependencies between skills'''
        dependency_issues = []
        
        # Build dependency graph
        dependency_graph = {}
        for skill, deps in self.skill_patterns['dependencies'].items():
            dependency_graph[skill] = list(deps)
        
        # Look for circular dependencies (simplified check)
        for skill, deps in dependency_graph.items():
            for dep in deps:
                if dep in dependency_graph and skill in dependency_graph[dep]:
                    dependency_issues.append(f'Circular dependency detected: {skill} â†” {dep}')
        
        return dependency_issues
    
    def generate_consistency_report(self):
        '''Generate comprehensive consistency report'''
        print('\\n' + '='*60)
        print('ğŸ” SKILL CONSISTENCY ANALYSIS REPORT')
        print('='*60)
        
        # Run all checks
        naming_issues = self.check_naming_consistency()
        structure_issues = self.check_structure_consistency()
        quality_issues = self.check_quality_scores()
        dependency_issues = self.check_circular_dependencies()
        
        all_issues = naming_issues + structure_issues + quality_issues + dependency_issues
        
        print(f'\\nğŸ“Š Repository Statistics:')
        print(f'  Total Skills: {self.stats.get(\"total_skills\", 0)}')
        print(f'  Categories: {len(self.skill_patterns[\"categories\"])}')
        print(f'  Unique Structures: {len(self.skill_patterns[\"structures\"])}')
        print(f'  Dependencies Found: {sum(len(deps) for deps in self.skill_patterns[\"dependencies\"].values())}')
        
        if all_issues:
            print(f'\\nâš ï¸  Consistency Issues Found ({len(all_issues)}):')
            for i, issue in enumerate(all_issues, 1):
                print(f'  {i}. {issue}')
        else:
            print('\\nâœ… No consistency issues found!')
        
        # Category breakdown
        if self.skill_patterns['categories']:
            print(f'\\nğŸ“ Category Breakdown:')
            for category, skills in sorted(self.skill_patterns['categories'].items()):
                avg_quality = sum(s['structure_score'] for s in skills) / len(skills) if skills else 0
                print(f'  {category}: {len(skills)} skills (avg quality: {avg_quality:.1%})')
        
        print('\\n' + '='*60)
        
        return len(all_issues) == 0

def main():
    checker = SkillConsistencyChecker()
    
    # Scan all skills
    checker.scan_all_skills()
    
    # Generate report
    is_consistent = checker.generate_consistency_report()
    
    # Save detailed report
    report_data = {
        'scan_date': datetime.now().isoformat(),
        'total_skills': checker.stats.get('total_skills', 0),
        'categories': list(checker.skill_patterns['categories'].keys()),
        'structures': dict(checker.skill_patterns['structures']),
        'naming_patterns': checker.skill_patterns['naming'],
        'dependencies': {k: list(v) for k, v in checker.skill_patterns['dependencies'].items()}
    }
    
    with open('consistency-report.json', 'w') as f:
        json.dump(report_data, f, indent=2)
    
    return is_consistent

if __name__ == '__main__':
    import sys
    from datetime import datetime
    success = main()
    sys.exit(0 if success else 1)
          "

      - name: Generate consistency summary
        if: always()
        run: |
          echo "ğŸ“‹ Generating consistency summary..."
          echo "## Skill Consistency Check Summary" > consistency-summary.md
          echo "" >> consistency-summary.md
          echo "âœ… Consistency analysis completed!" >> consistency-summary.md
          echo "" >> consistency-summary.md
          echo "**Check the workflow logs above for detailed results.**" >> consistency-summary.md

      - name: Upload consistency report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: consistency-report
          path: |
            consistency-report.json
            consistency-summary.md
          retention-days: 30

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let comment = `## ğŸ” Skill Consistency Check
            
            âœ… Skill consistency analysis completed!
            
            This workflow checks for consistency across all skills in the repository:
            - âœ¨ Naming convention consistency
            - ğŸ“ File structure standardization
            - ğŸ¯ Quality scoring and validation
            - ğŸ”— Dependency analysis
            - ğŸ“Š Cross-skill compatibility
            
            **Status**: ${{ job.status == 'success' && 'âœ… CONSISTENT' || 'âš ï¸  INCONSISTENCIES FOUND' }}
            
            Check the [workflow logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed analysis.
            
            ### What was checked:
            - âœ… Naming conventions (kebab-case, snake_case, etc.)
            - âœ… Required file structure (SKILL.md, README.md, template.md)
            - âœ… Content quality and completeness
            - âœ… Skill dependencies and circular references
            - âœ… Category organization and consistency
            
            ---
            *This comment was automatically generated by the skill consistency checker.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });